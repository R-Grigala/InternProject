# 5.რას დაბეჭდავს boo.py ში არსებული ბრძანება, print(__name__) თუ ფაილს გავუშვებთ შემდეგი ბრძანებით: python boo.py
# (1 Point)


# 1) "boo"

# 2) "__boo__"

# 3) "__main__"

# 4) შეცდომას, რადგან __name__ ცვლადი არ არსებობს

# answer:
# როდესაც Python-ის ფაილს უშვებთ პირდაპირ, __name__ ცვლადი აქვს ღირებულებას "__main__". ამიტომ, print(__name__) გამოიტანს "__main__".
# სწორი პასუხია: "main"


# 6.რომელია სწორი გზა იმისთვის რომ მრავალ ხაზიანი კომენტარი დავწეროთ პითონში?
# (1 Point)
 

# 1) * This is a comment *

# 2) // This is a comment

# 3) """ This is a comment """

# 4) <!-- This is a comment -->

# answer:
# Python-ში მრავალ ხაზიანი კომენტარის წერისთვის გამოიყენება სამი დახურული ციტატა (Triple Quotes):
# სწორი პასუხია:
# """ This is a comment """


# 7.როგორ ვხსნით "example.txt" ფაილს მხოლოდ ჩაწერის მიზნით?
# (1 Point)


# 1) file = open("example.txt", "w+")

# 2) file = open("example.txt", "r+")

# 3) file = open("example.txt", "w")

# 4) file = open("example.txt", "a")


# answer:
# მხოლოდ ჩაწერის მიზნით (და არა ლექერაში წასაკითხად ან დამატებისათვის) უნდა გამოვიყენოთ "w" რეჟიმი:
# სწორი პასუხია:
# file = open("example.txt", "w")


# 8.რას დაბეჭდავს მოცემული კოდი?
    # print (9 + 1 == "5 + 5")
# (1 Point)
 

# 1) True

# 2) False

# 3) მოხდება შეცდომა

# 4) კოდი არ გაეშვება

# answer:
# აქ, 9 + 1 არის 10, ხოლო "5 + 5" არის სტრინგი და მათ შორის შედარება დაბრუნებს False, რადგან სტრინგი და მთელი რიცხვი არ არის ტოლი.

# სწორი პასუხია:
# False


# 9.რა არის "cls" პარამეტრის დანიშნულება კლასის @classmethod მეთოდებში?
# (1 Point)


# 1) თავად კლასს უთითებს

# 2) სხვა კლასებს გადასცემს თავის თავს

# 3) კლასის ობიექტს უთითებს

# 4) აღნიშნავს რომ მეთოდი ეკუთვნის კლასს

# answer:
# "cls" მიუთითებს თავად კლასზე და არა კონკრეტულ ობიექტზე. ეს საშუალებას აძლევს მეთოდებს მუშაობა კლასის მონაცემებზე ან შექმნას ახალი კლასის ობიექტები.

# სწორი პასუხია:
# თავად კლასს უთითებს


# 10.რომელია tuple -ს სწორად განსაზღვირს ფორმა?
# (1 Point)


# 1) list1 = set_tuple([""])

# 2) list1 = [1, 2, 3]

# 3) tuple1 = (1)

# 4) list1 = (1,)


# answer:
# ერთი ელემენტის მქონე tuple-ის განსაზღვრისთვის საჭიროა , შემდეგი ტესტი:

# სწორი პასუხია:
# tuple1 = (1,)


# 11.რა არის პითონში კლასის მეთოდის განსასაზღვრათ საჭირო საკვანძო სიტყვა?
# (1 Point)


# 1) method

# 2) define

# 3) def

# 4) function

# answer:
# კლასის მეთოდების განსასაზღვრათ გამოიყენება def:

# სწორი პასუხია:
# def


# 12.  რას დაბეჭდავს მოცემული კოდის ფრაგმენტი?
    # x =x = 'Hello'
  
#    print(x[1:-1])
# (1 Point)


# 1) '

# 2) ell

# 3) oll

# 4) hel


# answer:
# აქ, x[1:-1] გამოიტანს სტრინგის მეორე ელემენტიდან ბოლო ელემენტის წინ, რაც არის 'ell'.

# სწორი პასუხია:
# ell


# 13.რომელი მეთოდი გამოიყენება კლასის ატრიბუტების განსასაზღვრად?
# (1 Point)


# 1) __new__

# 2) __init__

# 3) __constructor__

# 4) __meta__


# answer:
# კლასის ატრიბუტების განსაზღვრათ საჭიროა __init__ მეთოდი:

# სწორი პასუხია:
# __init__


# 14.რომელია იმპორტირების სწორი ფორმა?
# (1 Point)


# 1) from foo import boo

# 2) import boo from foo

# 3) include foo from boo

# 4) use foo from boo


# answer:
# foo მოდულიდან boo ფუნქციის იმპორტირებისთვის უნდა გამოიყენოთ from ... import ... ფორმა:

# სწორი პასუხია:
# from foo import boo



# 15.როგორ დავყოთ string ტიპის ცვლადი s, „გამოტევა“ სიმბოლოს მიხედვით?
# (1 Point)
 

# 1) String.split(s, " ")

# 2) “ “.toSplit(s)

# 3) s.split(" ")

# 4) split(s, " ")


# answer:
# split მეთოდი იყენებს სიმბოლოს, მაგალითად, „გამოტევა“:

# სწორი პასუხია:
# s.split(" ")



# 16.რას აკეთებს break პითონში?
# (1 Point)


# 1) break გამოიყენება მხოლოდ ციკლებში და იგი წვეტს ციკლის მუშაობას

# 2) break გამოიყენება ნებისმიერ ადგილას და წყვეტს პროგრამის მუშაობას

# 3) break გამოიყენება მხოლოდ ფუნქციებში და წყვეტს ფუნქციის მუშაობას

# 4) არცერთი ზემოთ ჩამოთვლილი არაა სწორი


# answer:
# break გამოიყენება ციკლებში და ავითარებს ციკლის მუშაობას:

# სწორი პასუხია:
# break გამოიყენება მხოლოდ ციკლებში და იგი წვეტს ციკლის მუშაობას



# 17.მონაცემთა რომელი ტიპის ცვლადი არის ცვალებადი(mutable) პითონში?
# (1 Point)


# 1) Dict

# 2) Int

# 3) Tuple

# 4) String


# answer:
# Dict (ლექსიკონი) არის ცვალებადი ტიპი, ხოლო Int, Tuple, და String არიან უცვლელი (immutable) ტიპები.

# სწორი პასუხია:
# Dict


# 18.როგორ გავიგოთ my_dict ლექსიკონში წყვილების რაოდენობა?
# (1 Point)


# size(my_dict)

# len(my_dict)

# length(my_dict)

# my_dict length


# answer:
# len ფუნქცია გაწვდოს ლექსიკონის წყვილების რაოდენობა:

# სწორი პასუხია:
# len(my_dict)


# 19.რა არის __del__ კლასის მეთოდის დანიშნულება პითონში?
# (1 Point)
 

# 1) კლასის შექმნისას განსაზღვრავს მის კონტექსტს

# 2) ობიექტი რომ სტრინგად გადავავაკეთოთ

# 3) ასრულებს დესტრუქტორის მოვალეობას და კლასის ობიექტის წაშლის შემდგომ ეშვება

# 4) ასრულებს კონტრქუტორის მოვალეობას და შექმნისას შლის კლასის სხვა ობიექტებს რამდგან მეხსიერება არ გადაგვევსოს


# answer:
# __del__ მეთოდი ასრულებს დესტრუქტორის ფუნქციას და ეშვება, როდესაც ობიექტი წაშლილია:

# სწორი პასუხია:
# ასრულებს დესტრუქტორის მოვალეობას და კლასის ობიექტის წაშლის შემდგომ ეშვება



# 20.  რას დაბეჭდავს კოდის მოცემული ფრაგმენტი?
    
#     Numnumbers = {1, 3, 4, 5}
#     numbers.add(2)
#     numbers.add(3)
#     numbers.remove(3)
#     print(numbers)

# (1 Point)
 

# 1) {1, 2, 3, 4, 5}

# 2) {1, 2, 4, 5}

# 3) {1, 2, 3, 3, 5}

# 4) არ დაბეჭდავს არაფერს, რადგან კოდი ერორზე გავა.


# answer:
# Numnumbers  != numbers

# სწორი პასუხია:
# არ დაბეჭდავს არაფერს, რადგან კოდი ერორზე გავა.



# 21.როგორ ამოვშალოთ my_dict ლექსიკონიდან K გასაღების მქონე წყვილი?
# (1 Point)


# 1) my_dict.remove(K)

# 2) my_dict.delete(K)

# 3) del my_dict[K]

# 4) my_dict[K] = None


# answer:
# del გამოიყენება ობიექტების წაშლისთვის:

# სწორი პასუხია:
# del my_dict[K]



# 22.რა უპირატესობა აქვს გენერატორების გამოიყენებას პითონში?
# (1 Point)



# 1) გვიმარტივებს ინდექსით წვდომას სიებში

# 2) ასწრაფებს ციკლის მუშაობას

# 3) მოიხმარს უფრო ნაკლებ მეხსიერებას

# 4) არცერთი ზემოთ ჩამოთვლილი უპირატესობა არ გააჩნია გენერატორს


# answer:
# გენერატორები მოიხმარს ნაკლებ მეხსიერებას, რადგან ისინი ელემენტების შექმნას საჭიროების მიხედვით ახდენენ:

# სწორი პასუხია:
# მოიხმარს უფრო ნაკლებ მეხსიერებას



# 23.რა არის map გენერატორის დანიშნულება პითონში?
# (1 Point)

 

# 1) მისი გამოყენებით შეგვიძლია წყვილების სია ავაგოთ

# 2) მისი გამოყენებით შეგვიძლია საიტერაციო ობიექტის თითოეული ელემენტზე ვიმოქმედოთ კონკრეტული ლოგიკით

# 3) მისი გამოყენებით შეგვიძლია დავფილტროთ საიტერაციო ობიექტის ელემენტები კონკრეტული ლოგიკის მიხედვით

# 4) მსგავსი გენერატორი არ არსებობს პითონში


# answer:
# map ფუნქცია საშუალებას იძლევა რაიმე ფუნქციის გამოყენებას სექვენციის თითოეულ ელემენტზე:

# სწორი პასუხია:
# მისი გამოყენებით შეგვიძლია საიტერაციო ობიექტის თითოეული ელემენტზე ვიმოქმედოთ კონკრეტული ლოგიკით



# 24.რა არის მთავარი განსხვავება პითონში კლასის მემკვიდრეობასა და კომპოზიციას შორის?
# (1 Point)
 


# 1) მემკვიდრეობა არის კოდის ხელახალი გამოყენების მექანიზმი, ხოლო კომპოზიცია გულისხმობს არსებული ობიექტებისგან ახალი ობიექტების შექმნას

# 2) კომპოზიცია არის პოლიმორფიზმის მისაღწევად, ხოლო მემკვიდრეობა ორიენტირებულია კაფსულაციაზე

# 3) მემკვიდრეობა საშუალებას აძლევს კლასს მიიღოს ატრიბუტები და მეთოდები სხვა კლასისგან, ხოლო კომპოზიცია გულისხმობს კლასების გაერთიანებას ახლის შესაქმნელად.

# 4) კომპოზიცია აყალიბებს “აქვს" ურთიერთობას კლასებს შორის, ხოლო მემკვიდრეობა აყალიბებს "არის" ურთიერთობას.


# answer:
# მემკვიდრეობა აყალიბებს "არის" ურთიერთობას, ხოლო კომპოზიცია აყალიბებს "აქვს" ურთიერთობას:

# მემკვიდრეობა: კლასი იღებს სხვა კლასის ატრიბუტებს და მეთოდებს.
# კომპოზიცია: კლასი შეიცავს სხვა კლასის ობიექტებს.

# სწორი პასუხია:
# კომპოზიცია აყალიბებს “აქვს" ურთიერთობას კლასებს შორის, ხოლო მემკვიდრეობა აყალიბებს "არის" ურთიერთობას